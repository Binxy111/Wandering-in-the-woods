<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Face Shooter</title>
<style>
  body, html { margin: 0; padding: 0; overflow: hidden; background: #222; }
  #score { position: absolute; top: 10px; left: 10px; font-size: 24px; color: white; z-index: 1; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
<script>
let scene, camera, renderer;
let faces = [];
let score = 0;

// Setup scene
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 5;

renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Light
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,10,7.5);
scene.add(light);

// Create faces as spheres
function spawnFace() {
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const material = new THREE.MeshStandardMaterial({color: 0xffff00});
    const face = new THREE.Mesh(geometry, material);
    face.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*5, -Math.random()*10 - 5);
    scene.add(face);
    faces.push(face);
}
for(let i=0;i<5;i++) spawnFace();

// Crosshair
const crosshair = document.createElement('div');
crosshair.style.position = 'absolute';
crosshair.style.top = '50%';
crosshair.style.left = '50%';
crosshair.style.width = '20px';
crosshair.style.height = '20px';
crosshair.style.marginLeft = '-10px';
crosshair.style.marginTop = '-10px';
crosshair.style.border = '2px solid red';
crosshair.style.borderRadius = '50%';
document.body.appendChild(crosshair);

// Handle shooting
window.addEventListener('click', () => {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera); // center of screen
    const intersects = raycaster.intersectObjects(faces);
    if(intersects.length > 0) {
        const face = intersects[0].object;
        scene.remove(face);
        faces = faces.filter(f => f !== face);
        score++;
        document.getElementById('score').textContent = 'Score: ' + score;
        spawnFace();
    }
});

// Device orientation control
let rotX = 0, rotY = 0;
window.addEventListener('deviceorientation', (e) => {
    rotY = THREE.MathUtils.degToRad(e.gamma || 0); // left/right
    rotX = THREE.MathUtils.degToRad(e.beta || 0);  // up/down
});

// Animate
function animate() {
    requestAnimationFrame(animate);
    camera.rotation.x = rotX;
    camera.rotation.y = rotY;

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
